# 算法训练营第一周：学习笔记

|数据结构|优点|缺点|
|---|---|---|
|数组|连续存储，随机访问复杂度O(1)|插入、删除复杂度O(n)|
|链表|分散存储，插入、删除复杂度O(1)|随机访问复杂度O(n)|
|栈|先入后出，入栈、出栈复杂度都是O(1)|栈是一种操作受限制的数据结构|
|队列|先入先出||


第一周算法的题目主要围绕数组、链表、栈和队列，都是很基本的数据结构。涉及到的算法题原理也简单清晰。

但实际以代码形式写出来，也需要一些时间，覃老师的“五毒神掌”目前我只用了前两掌，像接雨水这种题目，直接选择看题解然后自己再写；而有思路的题直接写代码。

通过这五天的每日一题，觉得有如下几点心得：

    1、 看题解的目的是获得自己不具备的思路，思路偏了死抠时间越长浪费的时间越多。
    2、 思路突破了，要试着把代码写出来。思路只是一个大框，很多细节只能在编码时遇到。
    3、 看题解也有技巧：可以只看最笨的题解，建立基本思路，编码实现，
        然后思考该实现存在哪些不足：是否存在重复计算？是否具备提前终止的条件？编码最复杂部分是否可以优化？
    通过这些过程，题解的很多其他解法就自然而然的突破了，这时再回过头去看优质题解，就可以把自己优化的方法上升到理论高度，也更容易看懂题解。

今天突然觉得算法和实际生活、工作中的各种问题都很相似：

    1、遇到了一个问题 或 需要提交一个方案 或 新需求；
    2、理解清除问题或需求；
    3、先想/选出一个基本解决方案；
    4、实施这个解决方案；
    5、根据实施中的反馈，不断优化方案；
    6、得出最优解。

用工程思维去学习算法，而不是用基础理论研究的思维来学习算法。

这里通过分析“接雨水”的解法，来实际说明一下这个解题过程。

读完题目，题意很明确：

    柱子间的凹槽就是能装下雨水的地方，计算出“凹槽的数量”就是能接住的“雨水数量”。

但想题解的时候，5分钟内没想出来，所以直接看题解去。这次只看了中文站官方题解的第一种解法：暴力求解

暴力求解的核心思想是：

    每个元素能接住的雨水量 = min( 该元素左侧所有元素的最大值 ，该元素右侧所有元素的最大值） - 该元素自身的值
    
有了这个公式，就有了解题思路，接下来就是动手写代码，把思路变成实际的程序。这个过程很重要。具体代码为 
```
int trap(int* height, int heightSize){
    int ans = 0;
    int i = 0;

    for ( i = 0; i < heightSize; ++i ) {
        int max_left = 0;
        int max_right = 0;
        int j = 0;

        for ( j = i; j >= 0; --j ) {
            max_left = max_left > height[j] ? max_left : height[j];
        }

        for ( j = i; j < heightSize; ++j ) {
            max_right = max_right > height[j] ? max_right : height[j];
        }

        int min_left_right = max_right > max_left ? max_left : max_right;

        ans += min_left_right - height[i];
    }
    return ans;
}


```
这种解法包含了两层的嵌套for循环，因此其时间复杂度是O(n^2),显然效率不高。

当写完这段代码、提交通过后，再在脑子里想一遍这个解题过程，这个时候才真正完成了由理解题意到真正解决问题的转变。

此时，再回过头继续看这段代码：是否存在不必要的重复计算？发现存在两处可以优化的地方：

    1、当前元素左侧的最大值，不需要每次都计算，
       只需把上一次计算的最大值，与当前元素的值，进行比较，就能确定最新的左侧最大值；
       如果当前元素的值是新的左侧最大值，不需要再寻找右侧最大值。

    2、当前元素右侧的最大值，不需要每次都计算，
       记录上次找到最大右侧值的下标，
       只要当前元素下标小于上述下标，就不需要再查找右侧最大值。

根据这两个优化位置，对代码进行了如下优化：

```
int trap(int* height, int heightSize){
    int ans = 0;
    int i = 0;
    int max_right_idx = 0;
    int min_left_right = 0;
    
    int max_left = 0;
    int max_right = 0;
    for ( i = 0; i < heightSize; ++i ) {
        int j = 0;
        
        int mheight = height[i];
        if ( max_left < mheight ) { //当前元素值是左侧的最大值，更新左侧最大值，结束本次循环
            max_left = mheight;
            continue;
        }

        if ( i >= max_right_idx ) { //当前元素下标大于右侧最大值下标，查找右侧最大值，并更新最大右侧值下标
            max_right = 0;
            for ( j = i; j < heightSize; ++j ) {
                int mheight = height[j];
                if ( max_right < mheight ) {
                    max_right = mheight;
                    max_right_idx = j;
                }
            }
        }
        min_left_right = max_right > max_left ? max_left : max_right;
        if( min_left_right >= height[i] ) {
            ans += min_left_right - height[i];
        }
    }
    return ans;
}

```

这样的代码，性能提高了不少，但可读性变得很差了。如果不是必要，工程上不建议引入这样的复杂性。一难维护，二容易引入隐藏的bug。

到这里，我也没有更好的思路了，就再次看题解，这次看了一个“单调递减栈”的解法，思路非常好，但第一遍直接没看懂。

反复看了几遍+读代码+听覃老师视频，才真正明白，核心思想是：

    当前元素比栈顶值小，直接入栈；
    当前元素比栈顶值大，弹栈并计算水容量 = ( min(当前值，新栈顶元素值) - 弹栈值 ) * (当前值索引 - 新栈顶元素索引 - 1)

具体代码为：
```
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        stack<int> s;

        for ( int i = 0; i < height.size(); ++i ){

            int cur_h = height[i];
            while( !s.empty() && ( height[ s.top() ] < cur_h ) ) {
                int prev_idx = s.top();
                s.pop();
                if( s.empty() ) {
                    break;
                }
                int l = s.top();
                int h = min( cur_h, height[l] ) - height[prev_idx];
                ans += ( i - l - 1 ) * h;
            }
            s.push(i);
        }

        return ans;
    }
};
```

接雨水还有其他解法，但目前没有时间看了。

这些过程并不是一天就完成的，反反复复的用了三天。

暴力法有时虽然很笨，但写出来能提高对题目的理解，像覃老师说的“很多暴力算法落实到代码上并不容易”。

而像栈这种解法，在对题目不是很理解，数据结构掌握不是很好时，很难直接想到。

工作较忙，自己可以利用的精力充沛时间很少，回想这一周，死磕题解和写代码费的时间较多，还需要深入理解并落实“五毒神掌”的精要。

加油，诸位。
